@page "/teamsessions/{Date:datetime}"
@inject BookingService BookingService
@inject TeamService TeamService
@attribute [Authorize]
@implements IDisposable
@using System.Globalization

<h2>Team session booking</h2>


@if (sessions == null)
{
<p>Loading sessions..</p>
}
else
{
<table style="min-width:400px;">
    <tr>
        <th colspan="4" class="text-center">@Date.ToString("MMMM", CultureInfo.InvariantCulture)</th>
    </tr>
    <tr>
        <th>@if (previousDayUrl != null)
                {<a href="@previousDayUrl">earlier</a>}
                else
                {<span class="text-muted">earlier</span>}</th>
        <th colspan="2" class="text-center">@Date.Day</th>
        <th class="text-right"><a href="@nextDayUrl">later</a></th>
    </tr>
    <tr>
        <th colspan="4" class="text-center">@Date.DayOfWeek</th>
    </tr>

    @foreach (var session in sessions)
        {
    <tr>
        <td>@session.StartTime</td>
        <td>@session.TeamName</td>
        <td class="text-center"><button @onclick="()=>ToggleReservationsViewFor(session)">@session.Available/@session.Size</button></td>
        <td><button disabled=@session.Disabled @onclick="()=>session.ToggleBookingState()">@session.BookingStateToggleText</button></td>
    </tr>
    @if (selectedSession == session.Generator)
            {
    <tr>
        <td colspan="4"><SessionInfo userIds=session.Reservations Size=session.Size /></td>
    </tr>
    }
    }
</table>
}


@code {
    private string nextDayUrl = null;
    private string previousDayUrl = null;
    private Dictionary<DateTime, string> ownReservations = new Dictionary<DateTime, string>();
    private IEnumerable<BookedTimeSlot> reservations = null;

    [Parameter]
    public DateTime Date { get; set; }


    private IEnumerable<SessionUiItem> sessions = null;

    private Object selectedSession = null;

    private void ToggleReservationsViewFor(SessionUiItem item)
    {
        if (item.Generator == selectedSession)
            selectedSession = null;
        else
            selectedSession = item.Generator;
        StateHasChanged();
    }

    public delegate Task BookingStateToggler();

    class SessionUiItem
    {
        public int Available { get; set; }
        public int Size { get; set; }
        public bool Disabled {get;set;} = false;
        public IEnumerable<string> Reservations;
        public string StartTime { get; set; }
        public string TeamName;
        public BookingStateToggler ToggleBookingState;
        public string BookingStateToggleText { get; set; }
        public const string BookingStateOnText = "Cancel booking";
        public const string BookingStateOffText = "Book";
        public Object Generator;
    }


    private static DateTime RoundToDays(DateTime date)
    {
        return new DateTime(date.Year, date.Month, date.Day, 0, 0, 0, date.Kind);
    }

    class ResolvedTeamSession
    {
    public TeamSession session { get; set; }
    public Team team { get; set; }
    }

    private async Task<IEnumerable<ResolvedTeamSession>> GetNextDailyTeamSessions(DateTime from)
    {
        var teamsessiondate = from;
        var sessions = await BookingService.GetTeamSessions(from, TimeSpan.FromDays(1));

        while(!sessions.Any())
        {
            teamsessiondate += TimeSpan.FromDays(1);
            sessions = await BookingService.GetTeamSessions(teamsessiondate, TimeSpan.FromDays(1));
        }
        return sessions.OrderBy(e=>e.StartTime).Select(e => new ResolvedTeamSession {
            team = TeamService.GetTeam(e.TeamId),
            session =e
    });
    }

    private async Task<DateTime> GetPreviousTeamSessionDateBefore(DateTime date)
    {
        var teamsessiondate = date;

        while (true)
        {
            teamsessiondate -= TimeSpan.FromDays(1);
            if ((await BookingService.GetTeamSessions(teamsessiondate, TimeSpan.FromDays(1))).Any())
                return teamsessiondate;
        }
    }

    private async Task<DateTime> GetNextTeamSessionDateAfter(DateTime date)
    {
        var teamsessiondate = date;

        while (true)
        {
            teamsessiondate += TimeSpan.FromDays(1);
            if ((await BookingService.GetTeamSessions(teamsessiondate, TimeSpan.FromDays(1))).Any())
                return teamsessiondate;
        }
    }

    protected async override Task OnParametersSetAsync()
    {
        Date = RoundToDays(Date);
        var inputDate = Date;
        if (Date < DateTime.Today)
            Date = DateTime.Today;

        var nextTeamSessions = await GetNextDailyTeamSessions(Date);
        Date = RoundToDays(nextTeamSessions.First().session.StartTime);
        nextDayUrl = $"/teamsessions/{(await GetNextTeamSessionDateAfter(Date)).ToString("yyyy-MM-dd", CultureInfo.InvariantCulture)}";
        previousDayUrl = null;
        if (Date > DateTime.Today)
        {
            var previousSessionDate = await GetPreviousTeamSessionDateBefore(inputDate);
            if (previousSessionDate >= DateTime.Today)
                previousDayUrl = $"/teamsessions/{previousSessionDate.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture)}";
        }

        reservations = await BookingService.GetAllReservations(Date, TimeSpan.FromDays(1));

        sessions = nextTeamSessions.Where(e => e.session.StartTime +e.team.Duration >= DateTime.Now).Select(e =>
        {
            var reservations = GetReservations(e.session);
            var isBooked = ownReservations.ContainsKey(e.session.StartTime);
            
            BookingStateToggler toggleState = async () => await Book(e.session);
            if (isBooked)
                toggleState = async () => await CancelBooking(e.session);
            var res = new SessionUiItem
            {
                Available = e.team.Size - reservations.Count(),
                StartTime = e.session.StartTime.ToString("HH:mm", CultureInfo.InvariantCulture),
                BookingStateToggleText = isBooked ? SessionUiItem.BookingStateOnText : SessionUiItem.BookingStateOffText,
                ToggleBookingState = toggleState,
                Reservations = reservations,
                Size = e.team.Size,
                Generator = e.session,
                TeamName = e.team.Name
            };
            int maxBookings = 0;
            if (!isBooked && e.team.Limits.TryGetValue(TeamLimit.ActiveBookings, out maxBookings))
            {
                res.Disabled = ownReservations.Count(kv => kv.Key > DateTime.Now && kv.Value == e.team.Id) >= maxBookings;
            }
            
            return res;
        });
    }

    protected async override Task OnInitializedAsync()
    {
        var ownBookings = await BookingService.GetLoggedOnUserReservations();

        var ownTeamBookings = ownBookings.Where(e => e.TeamId != "open");
        foreach(var teamBooking in ownTeamBookings)
        {
            ownReservations.Add(teamBooking.StartTime, teamBooking.TeamId);
        }
        BookingService.OnBookingsChanged += this.BookingsChanged;
    }

    private IEnumerable<string> GetReservations(TeamSession session)
    {
        var res = reservations.Where(res => res.StartTime == session.StartTime);
        if (res.Any())
        {
            var teamReservations = res.Select(e => e.TeamReservations).Single();
            List<string> reservationsForTeam = null;
            if (teamReservations.TryGetValue(session.TeamId, out reservationsForTeam))
            {
                return reservationsForTeam;
            }
            return Enumerable.Empty<string>();
        }
        return Enumerable.Empty<string>();
    }

    private async Task Book(TeamSession sessionToBook)
    {
        await BookingService.MakeTeamReservation(sessionToBook);
        ownReservations[sessionToBook.StartTime] = sessionToBook.TeamId;
    }

    private async Task CancelBooking(TeamSession sessionToBook)
    {
        await BookingService.CancelTeamReservation(sessionToBook);
        ownReservations.Remove(sessionToBook.StartTime);
    }

    private async void BookingsChanged()
    {
        reservations = await BookingService.GetAllReservations(Date, TimeSpan.FromDays(1));
        await InvokeAsync(() => StateHasChanged());
    }

    public void Dispose()
    {
        BookingService.OnBookingsChanged -= this.BookingsChanged;
    }
    
}
